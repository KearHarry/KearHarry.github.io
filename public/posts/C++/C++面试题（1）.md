---

title: c++面试题（1）

date: 2026年2月13日

category: [C++面试题]

excerpt: C++底层原理与实现

---

1.左值和右值的区别？

在 C++ 中，理解左值和右值最核心的标准是**是否有持久的内存地址**和**是否可以被安全地取地址**。

- **左值 (Locator Value / Lvalue)：**
  - **定义：** 指向内存中明确位置（具有持久地址）的对象。
  - **特点：** 生命周期长于单条语句；可以对它使用取地址符 `&`。
  - **示例：** 变量名（`int a = 1;` 中的 `a`）、解引用的指针（`*p`）、返回左值引用的函数调用。
- **右值 (Read Value / Rvalue)：**
  - **定义：** 不具有持久内存地址的临时数据（通常存放在寄存器中或作为临时对象）。
  - **特点：** 生命周期短暂（通常在表达式结束后就销毁）；**不能**对它使用取地址符 `&`。
  - **示例：** 字面常量（如 `10`, `true`）、表达式的求值结果（如 `x + y`）、返回非引用的函数调用（如 `int func()`）。

> **💡 一句话总结：** 能取地址、有名字的就是左值；不能取地址、没名字的临时变量就是右值。



2.针对右值的优化有哪些？

C++ 引入右值主要是为了榨干性能，避免不必要的深拷贝。针对右值的优化主要有以下两种形式：

- **编译器层面的优化：返回值优化 (RVO / NRVO - Return Value Optimization)**
  - 当函数返回一个临时对象（右值）时，编译器会进行“拷贝消除（Copy Elision）”。它会直接在接收该返回值的变量所在的内存地址上构造对象，从而完全省去了一次拷贝构造和析构的过程。在 C++17 中，对于纯右值的 RVO 已经是强制的。
- **语言层面的优化：右值引用 (Rvalue Reference) 与移动语义 (Move Semantics)**
  - C++11 引入了右值引用（使用 `&&` 表示，如 `int&&`），允许我们“绑定”到一个即将销毁的右值上。
  - 这使得我们可以为类编写**移动构造函数**和**移动赋值运算符**。当传入的对象是一个右值（即将消亡的临时对象）时，编译器会优先调用移动版本，直接“偷走”右值内部的资源（如堆内存指针），而不是进行昂贵的深拷贝。



3.移动语义的底层是怎么实现的？

移动语义的底层其实是一个**“类型强转”** + **“指针接管”**的魔术。

1. **`std::move` 的本质：** 很多人误以为 `std::move` 会移动数据，其实它**什么都不移动**。`std::move` 在底层的实现仅仅是一个类型转换：它通过模板萃取和 `static_cast`，无条件地将一个左值强制转换为**右值引用**（`T&&`）。
2. **真正的“移动”发生在移动构造函数/移动赋值运算符中：** 当你将一个对象转为右值引用后，就会触发目标对象的移动构造函数。在移动构造函数内部，底层实现如下：
   - **浅拷贝：** 将源对象（右值）内部的指针（或资源句柄）直接复制给当前对象。
   - **剥夺所有权：** 将源对象的指针置为 `nullptr`（或置为无效状态）。
   - **结果：** 资源的所有权从一个对象转移到了另一个对象，避免了重新开辟内存和复制数据。源对象在随后析构时，由于指针是 `nullptr`，`delete nullptr` 是安全的，不会导致双重释放（Double Free）。



4.Malloc 和 new的区别是什么？

这是最经典的 C vs C++ 问题，主要区别在于**对象意识**和**类型安全**。

| **维度**     | **malloc / free**                                     | **new / delete**                                      |
| ------------ | ----------------------------------------------------- | ----------------------------------------------------- |
| **本质**     | C 语言的标准**库函数**                                | C++ 的**运算符** (关键字)                             |
| **内存分配** | 只负责分配指定字节数的原始内存                        | 分配内存，并**调用类的构造函数**初始化对象            |
| **内存释放** | 只负责释放内存                                        | 先**调用类的析构函数**清理资源，再释放内存            |
| **返回类型** | 返回 `void*`，需要手动强制类型转换                    | 返回具体类型的指针，类型安全                          |
| **参数**     | 需要手动计算并传入分配的字节数（如 `sizeof(int)*10`） | 自动计算所需的内存大小，只需指定类型和数量            |
| **失败处理** | 内存分配失败时返回 `NULL`                             | 内存分配失败时默认抛出 `std::bad_alloc` 异常          |
| **重载**     | 不可重载                                              | 允许被重载（重载 `operator new` / `operator delete`） |

追问：如果我想在已经分配好的内存上调用构造函数，应该怎么做？



5.为什么要内存对齐？

内存对齐是指数据在内存中的存放地址必须是某个值（通常是数据类型自身大小或平台指定的对齐模数）的整数倍。主要有以下两个根本原因：

1. **硬件性能原因（最核心）：** CPU 读取内存不是按单个字节读取的，而是按块（如 4 字节、8 字节、或者 64 字节的 Cache Line）读取的。
   - **对齐时：** CPU 一次读取就可以把需要的数据取出来。
   - **不对齐时：** 一个数据可能会跨越两个读取块的边界。CPU 需要执行**两次**内存访问操作，然后将两块数据进行拼接、剔除，才能得到最终数据，这会极大地降低系统的运行效率。
2. **硬件平台限制：** 并非所有的硬件平台都能访问任意地址上的任意数据。某些特定的 CPU 架构（如部分 ARM、SPARC）不支持非对齐的内存访问。如果遇到未对齐的地址，硬件会直接抛出硬件异常（如 Bus Error）。



6.栈和堆的区别？

理解栈和堆的区别，就是理解程序运行时的内存布局。

| **维度**     | **栈 (Stack)**                                               | **堆 (Heap)**                                                |
| ------------ | :----------------------------------------------------------- | ------------------------------------------------------------ |
| **管理方式** | **自动管理**。由编译器自动分配和释放（存储局部变量、函数参数、返回地址等）。 | **手动管理**。由程序员手动分配和释放（使用 `new`/`malloc`），容易造成内存泄漏。 |
| **空间大小** | **较小**。通常在编译时确定，一般只有几 MB（如 Linux 默认 8MB），极易发生栈溢出（Stack Overflow）。 | **很大**。受限于操作系统的虚拟内存，通常可以达到 GB 级别。   |
| **分配效率** | **极高**。栈是机器系统提供的数据结构，CPU 有专门的寄存器（如 ESP/RSP）存放栈顶地址，有专门的指令（push/pop）执行操作。 | **较低**。堆是 C/C++ 库函数提供的，分配时需要去空闲内存链表中寻找合适的空间，还涉及到操作系统内核的调用。 |
| **内存碎片** | **无碎片**。栈是严格的后进先出（LIFO）结构，不会产生内存碎片。 | **有碎片**。频繁的 `new`/`delete` 会造成内存空间的不连续，产生大量碎片。 |
| **生长方向** | **向下生长**。向着内存地址减小的方向扩展。                   | **向上生长**。向着内存地址增加的方向扩展。                   |

7.栈和堆分别存储哪些数据？

9.shared_ptr是线程安全的吗？

10.如何实现线程安全？

11.C函数malloc的原理是什么？

12.静态库和动态库的区别？

13.C++多态的实现原理？

14.C++中实现一个支持反射的类有哪几个步骤？

15.虚函数是怎么实现的？

16.怎么判断内存泄漏？

17.什么是智能指针？

18.智能指针的类型有哪些？分别有什么作用？

19.class和struct的区别？

20.虚继承是什么？

21.虚继承有哪些注意事项？

22.栈帧是什么？

23.右值引用移动语义是什么解决什么问题？

24.移动构造怎么写？

25.static_cast和dynamic_cast有什么区别？

26.什么是 Placement New？有什么应用场景？